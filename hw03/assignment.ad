---
title: "HW03: AnalÃ½za sieÅ¥ovÃ©ho zÃ¡znamu"
layout: "homework"
list-of-files: ["capture.h", "capture.c", "nft.c"]
solution-path: /home/kontr/pb071/hw03/nft
publish: now
deadline-early: 2022-04-10 24:00
deadline-final: 2022-04-13 24:00
authors:
  - xbaso
  - xbobon
  - xsedla10
  - xnagy1
---

== Predstavenie Ãºlohy

V tejto domÃ¡cej Ãºlohe si vyskÃºÅ¡ate naimplementovaÅ¥ malÃº aplikÃ¡ciu s nÃ¡zvom
nft â€“ network filtering tool.
Tento program dokÃ¡Å¾e naÄÃ­taÅ¥ zÃ¡znam sieÅ¥ovej komunikÃ¡cie uloÅ¾enÃ½ v sÃºbore pcap
a vypÃ­saÅ¥ o Åˆom rÃ´zne Å¡tatistiky.

Pcap je Å¡iroko pouÅ¾Ã­vanÃ© rozhranie pre prÃ¡cu so zÃ¡znamami sieÅ¥ovej komunikÃ¡cie.
TakÃ½to zÃ¡znam si na svojom poÄÃ­taÄi mÃ´Å¾ete vytvoriÅ¥ naprÃ­klad pomocou programu
Wireshark, ktorÃ½ vÃ¡m ho dovolÃ­ uloÅ¾iÅ¥ do sÃºboru pcap.
Pre vyrieÅ¡enie domÃ¡cej Ãºlohy vÅ¡ak nemusÃ­te formÃ¡tu pcap sÃºborov Ãºplne rozumieÅ¥,
vÅ¡etky dÃ´leÅ¾itÃ© informÃ¡cie nÃ¡jdete v zadanÃ­.
KniÅ¾nicu pre naÄÃ­tavanie dÃ¡t v tomto formÃ¡te vÃ¡m dodÃ¡vame v kostre, vaÅ¡ou Ãºlohou
bude ju sprÃ¡vne pouÅ¾iÅ¥.

=== Ako tÃºto domÃ¡cu Ãºlohu rieÅ¡iÅ¥?

. PreÄÃ­tajte si informÃ¡cie o dodanej kniÅ¾nici a pozrite sa do sÃºboru `demo.c`.
  SkÃºste pomocou funkcie `demo1` vypÃ­saÅ¥ informÃ¡cie z nejakÃ©ho sÃºboru pcap
  (jeden mÃ¡te prichystanÃ½ v kostre).
  Pochopte, Äo funkcia robÃ­. AÅ¾ potom sa pustite do programovania.

. Implementujte prvÃº ÄasÅ¥ zadania. SkÃºste pouÅ¾iÅ¥ rieÅ¡enie tejto Äasti vo funkcii
  `demo2` v sÃºbore `demo.c`.

. Implementujte druhÃº ÄasÅ¥ zadania a skÃºste pouÅ¾iÅ¥ rÃ´zne filtre v `demo.c`.
  To istÃ© spravte aj pre tretiu ÄasÅ¥.

. Implementujte Å¡tvrtÃº ÄasÅ¥ zadania a otestujte jej funkÄnosÅ¥ ako pouÅ¾itÃ­m
  vÃ½slednÃ©ho programu, tak pomocou testov.

=== KniÅ¾nica pre prÃ¡cu so sÃºbormi v pcap formÃ¡te

K rieÅ¡eniu Ãºlohy pouÅ¾ijete jednoduchÃº kniÅ¾nicu pre prÃ¡cu so sÃºbormi pcap, ktorÃº
nÃ¡jdete v kostre Ãºlohy â€“ konkrÃ©tne v sÃºboroch `pcap.h` a `pcap.c`.
Na to, aby ste vyrieÅ¡ili tÃºto Ãºlohu, nemusÃ­te sÃºbor `pcap.c` vÃ´bec otvÃ¡raÅ¥,
ani nemusÃ­te rozumieÅ¥ jeho obsahu.

PrÃ¡cu s kniÅ¾nicou zaÄnete volanÃ­m funkcie `init_context`, ktorej predÃ¡te cestu
k sÃºboru a Å¡truktÃºru `pcap_context`, ktorÃº danÃ¡ funkcia naplnÃ­.

```c
int init_context(struct pcap_context *context, const char *filename);
```

NaplnenÃº Å¡truktÃºru `pcap_context` si treba drÅ¾aÅ¥, aÅ¾ kÃ½m prÃ¡ca so sÃºborom
neskonÄÃ­, pretoÅ¾e ju budÃº potrebovaÅ¥ funkcie na naÄÃ­tavanie dÃ¡t zo zadanÃ©ho
sÃºboru.
Pre kaÅ¾dÃ½ sÃºbor pcap, ktorÃ½ chcete otvoriÅ¥, si staÄÃ­ vytvoriÅ¥ a nainicializovaÅ¥
novÃº Å¡truktÃºru `pcap_context`, takÅ¾e mÃ´Å¾ete maÅ¥ otvorenÃ½ch niekoÄ¾ko sÃºborov pcap
naraz.
Na vyrieÅ¡enie Ãºlohy vÃ¡m vÅ¡ak vÅ¾dy bude staÄiÅ¥ maÅ¥ otvorenÃ½ nanajvÃ½Å¡ jeden.
O obsah Å¡truktÃºry `pcap_context` sa nemusÃ­te zaujÃ­maÅ¥, akurÃ¡t ju na konci
programu musÃ­te sprÃ¡vne uvoÄ¾niÅ¥ pomocou volania funkcie `destroy_context`,
ktorÃ¡ sa postarÃ¡ o zavrenie sÃºboru, ku ktorÃ©mu danÃ¡ Å¡truktÃºra patrÃ­.

```c
void destroy_context(struct pcap_context *context);
```

SÃºbor pcap zaÄÃ­na hlaviÄkou, ktorÃº musÃ­te naÄÃ­taÅ¥ ako prvÃº.
Na to pouÅ¾ijete funkciu `load_header`, ktorÃ¡ hlaviÄku naÄÃ­ta do pamÃ¤te, na ktorÃº
jej dÃ¡me ukazovateÄ¾.

```c
int load_header(struct pcap_context *context, struct pcap_header_t *header);
```

V hlaviÄke sÃºboru je jedna dÃ´leÅ¾itÃ¡ poloÅ¾ka â€“ magickÃ© ÄÃ­slo (Magic Number).
TÃ¡to 32 bitovÃ¡ konÅ¡tanta mÃ´Å¾e nadobÃºdaÅ¥ jednu z dvoch hodnÃ´t (hexadecimÃ¡lne):

. `0xA1B2C3D4` â€“ znamenÃ¡, Å¾e ÄasovÃ© znÃ¡mky v hlaviÄkÃ¡ch paketov sÃº uloÅ¾enÃ© v sekundÃ¡ch a mikrosekundÃ¡ch.
. `0xA1B23C4D` â€“ znamenÃ¡, Å¾e ÄasovÃ© znÃ¡mky v hlaviÄkÃ¡ch paketov sÃº uloÅ¾enÃ© v sekundÃ¡ch a nanosekundÃ¡ch.

NÃ¡sledne mÃ´Å¾ete zaÄaÅ¥ ÄÃ­taÅ¥ pakety pomocou funkcie `load_packet`, ktorÃ¡
zo sÃºboru preÄÃ­ta prÃ¡ve jeden paket a uloÅ¾Ã­ ho na urÄenÃ© miesto v pamÃ¤ti.
Na vytvorenie kÃ³piÃ­ paketov pouÅ¾Ã­vajte nami dodanÃº funkciu `copy_packet`.
KaÅ¾dÃ½ paket, ktorÃ½ vznikol volanÃ­m Ä¾ubovoÄ¾nej z tÃ½chto funkciÃ­, musÃ­te pred
uvoÄ¾nenÃ­m daÅ¥ funkcii `destroy_packet`, ktorÃ¡ uvoÄ¾nÃ­ dodatoÄnÃº pamÃ¤Å¥
alokovanÃº samotnou kniÅ¾nicou.

```c
int load_packet(struct pcap_context *context, struct packet_t *packet);
int copy_packet(struct packet_t *src, struct packet_t *dest);
void destroy_packet(struct packet_t *packet);
```

Funkcie s nÃ¡vratovÃ½m typom `int` vracajÃº v prÃ­pade Ãºspechu `0`, v prÃ­pade
zlyhania vrÃ¡tia nenulovÃ½ nÃ¡vratovÃ½ kÃ³d.

MÃ´Å¾e sa vÃ¡m tieÅ¾ hodiÅ¥ pomocnÃ¡ funkcia z kniÅ¾nice, pomocou ktorej mÃ´Å¾ete vypÃ­saÅ¥
informÃ¡cie o danom pakete.

MÃ´Å¾ete si vÅ¡imnÃºÅ¥, Å¾e dodanÃ¡ zjednoduÅ¡enÃ¡ kniÅ¾nica ignoruje a preskakuje
v naÄÃ­tavanÃ½ch sÃºboroch vÅ¡etky pakety, ktorÃ© nemajÃº protokol IPv4.
V tejto Ãºlohe sa budeme zaoberaÅ¥ iba IPv4 paketmi.

=== Demo

V kostre Ãºlohy nÃ¡jdete sÃºbor `demo.c` a v Åˆom funkciu `main`.
V tomto sÃºbore sa mÃ´Å¾ete hraÅ¥ s vaÅ¡im doterajÅ¡Ã­m rieÅ¡enÃ­m a testovaÅ¥ ho.
Obsahuje tieÅ¾ funkciu `demo1`, ktorÃ¡ s pouÅ¾itÃ­m dodanej kniÅ¾nice naÄÃ­ta hlaviÄku
sÃºboru pcap, potom naÄÃ­ta prvÃ© 2 pakety a vypÃ­Å¡e informÃ¡cie o nich.
Ak sa zamyslÃ­te nad obsahom tejto funkcie, implementÃ¡ciu prvej Äasti Ãºlohy by
ste mali zvlÃ¡dnuÅ¥ bez vÃ¤ÄÅ¡Ã­ch problÃ©mov.

V kostre nÃ¡jdete aj jednoduchÃ½ sÃºbor pcap (`test.pcap`), ktorÃ½ obsahuje 10
paketov.
Nad nÃ­m sÃº postavenÃ© testy naneÄisto.
Na prehliadanie, vytvÃ¡ranie a editÃ¡ciu vlastnÃ½ch sÃºborov pcap mÃ´Å¾ete pouÅ¾iÅ¥
program Wireshark â€“ internety sÃº plnÃ© nÃ¡vodov na prÃ¡cu s nÃ­m.

== Zadanie

=== 1. NaÄÃ­tanie celÃ©ho zÃ¡znamu

V prvej Äasti budete implementovaÅ¥ naÄÃ­tanie kompletnÃ©ho obsahu sÃºboru pcap
pomocou dodanej kniÅ¾nice.
V sÃºbore `capture.h` sÃº deklarÃ¡cie niekoÄ¾kÃ½ch funkciÃ­, ktorÃ½ch implementÃ¡cie
budete pÃ­saÅ¥ do sÃºboru `capture.c`.
PoÄet a hlaviÄky funkciÃ­ v `capture.h` nesmiete nijak meniÅ¥.
V sÃºbore sa nachÃ¡dza Å¡truktÃºra `capture_t`, ktorÃº mÃ¡te za Ãºlohu navrhnÃºÅ¥ vy sami.
Funkcia `load_capture` naÄÃ­ta hlaviÄku a potom vÅ¡etky pakety zo zadanÃ©ho sÃºboru.
SpÃ´sob, akÃ½m si budete ukladaÅ¥ dopredu neznÃ¡my poÄet paketov v Å¡truktÃºre
`capture_t` je vo vaÅ¡ej rÃ©Å¾ii.
DÃ´leÅ¾itÃ© je, aby bola po zavolanÃ­ `destroy_capture` korektne uvoÄ¾nenÃ¡ vÅ¡etka
pamÃ¤Å¥ alokovanÃ¡ v priebehu naÄÃ­tavania.

V prÃ­pade pouÅ¾itia spÃ¡janÃ©ho zoznamu mÃ´Å¾te potrebnÃ© Å¡truktÃºry pridaÅ¥ do sÃºboru
`capture.h`.

```c
struct capture_t {
    /* Sem vloÅ¾te implementÃ¡ciu Å¡truktÃºry */
}

int load_capture(struct capture_t *capture, const char *filename);
void destroy_capture(struct capture_t *capture);
```

TIP: Zamyslite sa nad tÃ½m, Äi `pcap_context` musÃ­ nutne byÅ¥ sÃºÄasÅ¥ou `capture_t`.
K volaniu funkcie `destroy_context` by malo dÃ´jsÅ¥ eÅ¡te vo funkcii `load_capture`.

Ak volanie funkcie `load_packet` zlyhÃ¡ v priebehu naÄÃ­tavania, funkcia
`load_capture` korektne uvoÄ¾nÃ­ vÅ¡etku doteraz alokovanÃº pamÃ¤Å¥ a vrÃ¡ti `-1`.
Inak povedanÃ©, aj keÄ sa podarÃ­ zo sÃºboru s 50 paketmi korektne naÄÃ­taÅ¥ 49
paketov a poslednÃ© volanie `load_packet` zlyhÃ¡, `load_capture` musÃ­ tento stav
zvlÃ¡dnuÅ¥ a pred ukonÄenÃ­m sa postaraÅ¥ o uvoÄ¾nenie vÅ¡etkÃ½ch doteraz naÄÃ­tanÃ½ch
paketov.

Pakety ukladajte v poradÃ­, v ktorom sÃº uloÅ¾enÃ© v pcap sÃºbore â€“ teda v rovnakom,
v akom vÃ¡m ich bude vracaÅ¥ postupnÃ© volanie funkcie `load_packet`.
Funkcie `get_header` a `get_packet` iba vracajÃº ukazateÄ¾ na hlaviÄku pcap alebo
paket uloÅ¾enÃ½ vnÃºtri Å¡truktÃºry `capture_t`, Å¾iadne dÃ¡ta ani nekopÃ­rujÃº,
ani nevytvÃ¡rajÃº.
Funkcia `packet_count` vracia poÄet paketov vnÃºtri Å¡truktÃºry `capture_t`.
Funkcia `data_transfered` potom vracia sÃºÄet veÄ¾kostÃ­ vÅ¡etkÃ½ch paketov v zÃ¡zname
(priÄom vÃ¡s zaujÃ­ma hodnota `orig_len` v `packet_header_t`).

```c
struct pcap_header_t* get_header(const struct capture_t *const capture);
struct packet_t* get_packet(const struct capture_t *const capture, size_t index);

size_t packet_count(const struct capture_t *const capture);
size_t data_transfered(const struct capture_t *const capture);
```

=== 2. Filtrovanie

V druhej Äasti Ãºlohy budete implementovaÅ¥ funkcie na filtrovanie paketov
na zÃ¡klade ich vlastnostÃ­.

Naimplementujte vÅ¡etky funkcie deklarovanÃ© v hlaviÄke `capture.h` v tvare:

```c
int filter_<nieÄo>(const struct capture_t *const original, struct capture_t *filtered, <ÄalÅ¡ie parametre pre filtrovanie>);
```

Tieto funkcie sa budÃº sprÃ¡vaÅ¥ veÄ¾mi podobne: kaÅ¾dÃ¡ vytvorÃ­ kÃ³piu pÃ´vodnej
Å¡truktÃºry `original` a naplnÃ­ novÃº Å¡truktÃºru `filtered` tÃ½mi paketmi
zo Å¡truktÃºry `original`, ktorÃ© vyhovujÃº danÃ©mu kritÃ©riu.
Å truktÃºra `original` musÃ­ zostaÅ¥ nezmenenÃ¡, filtrovacia funkcia vÅ¡etky
vyhovujÃºce pakety *skopÃ­ruje* do novej Å¡truktÃºry `filtered`.
NeskorÅ¡ie zmazanie Ä¾ubovoÄ¾nej z tÃ½chto 2 Å¡truktÃºr nesmie nijak ovplyvniÅ¥ tÃº druhÃº.
Podobne, pokiaÄ¾ neskÃ´r dÃ´jde k zmene obsahu paketu v jednej zo Å¡truktÃºr, nijak
prpreesa tÃ½m nezmenÃ­ paket v tej druhej.

IMPORTANT: Nezabudnite, Å¾e novo vzniknutÃ¡ Å¡truktÃºra `filtered` musÃ­ byÅ¥
plnohodnotnou kÃ³piou pÃ´vodnej Å¡truktÃºry (okrem nevyhovujÃºcich paketov), takÅ¾e
to stÃ¡le musÃ­ byÅ¥ validnÃ¡ Å¡truktÃºra `capture_t`.
MusÃ­ byÅ¥ pouÅ¾iteÄ¾nÃ¡ vo vÅ¡etkÃ½ch funkciÃ¡ch z tejto domÃ¡cej Ãºlohy, naprÃ­klad
v ÄalÅ¡Ã­ch filtrovacÃ­ch funkciÃ¡ch (a tieÅ¾ na nej musÃ­ korektne fungovaÅ¥ volanie
funkcie `get_header`ğŸ˜‰). TieÅ¾ sa predpokladÃ¡, Å¾e bude neskÃ´r upratanÃ¡ pomocou
funkcie `destroy_capture`, rovnako ako Å¡truktÃºry, ktorÃ© vznikli volanÃ­m
`load_capture`.

PokiaÄ¾ dÃ´jde v priebehu filtrovania ku problÃ©mu v niektorej z funkciÃ­ kniÅ¾nice
`pcap.h`, filtrovacia funkcia vrÃ¡ti `-1` a pre Å¡truktÃºru `filtered` platÃ­ to
istÃ©, Äo pre Å¡truktÃºru vo funkcii `load_capture` â€“ nesmie po nej zostaÅ¥ Å¾iadna
neuvoÄ¾nenÃ¡ pamÃ¤Å¥.
Å truktÃºra `original` vÅ¡ak zostane nezmenenÃ¡ aj v prÃ­pade zlyhania.

==== Ako na masky?

Masku definujeme ako poÄet prvÃ½ch _n_ bitov poÄiatoÄnej IP adresy v tvare `IP/n`.
Adresy vyhovujÃºce zadanej maske sÃº tie, ktorÃ© sa zhodujÃº s poÄiatoÄnou adresou
v prvÃ½ch _n_ bitoch.
Ako prÃ­klad mÃ´Å¾eme pouÅ¾iÅ¥ adresu/masku `127.0.0.1/8`:

```
127.0.0.1 = 01111111 00000000 00000000 00000001
Mask   /8 = 11111111 00000000 00000000 00000000
IP & Mask = 01111111 00000000 00000000 00000000
```

Tejto maske budÃº teda vyhovovaÅ¥ vÅ¡etky adresy, ktorÃ© po aplikÃ¡cii bitovej
operÃ¡cie `&` s maskou `/8` dajÃº rovnakÃ½ vÃ½sledok ako poÄiatoÄnÃ¡ adresa.
Teda adresy, ktorÃ© majÃº v prvÃ½ch 8 bitoch `01111111`, naprÃ­klad `127.0.1.1`.

Ak nerozumiete formÃ¡tu dÃ¡t, ktorÃ© funkcie na filtrovanie pomocou masiek
pouÅ¾Ã­vajÃº, nahliadnite do priloÅ¾enÃ½ch testov.

=== 3. Å tatistiky a analÃ½za tokov

Teraz sa dostÃ¡vame k jadru domÃ¡cej Ãºlohy â€“ k analÃ½ze dÃ¡tovÃ½ch tokov.
Pre potreby tejto Ãºlohy budeme zjednodÅ¡ene predpokladaÅ¥, Å¾e dÃ¡tovÃ½ tok sÃº vÅ¡etky
pakety s unikÃ¡tnou dvojicou zdrojovej a cieÄ¾ovej IP adresy.
V nasledujÃºcom prÃ­klade kaÅ¾dÃ½ riadok zodpovedÃ¡ jednÃ©mu paketu, kde sa na Ä¾avej
strane nachÃ¡dza jeho zdrojovÃ¡ adresa a na pravej jeho cieÄ¾ovÃ¡ adresa.

```
N. ip_from  -> ip_to
-----------------------
1. 11.0.0.0 -> 22.0.0.0
2. 22.0.0.0 -> 11.0.0.0
3. 33.0.0.0 -> 44.0.0.0
4. 11.0.0.0 -> 22.0.0.0
5. 11.0.0.0 -> 44.0.0.0
6. 33.0.0.0 -> 44.0.0.0
7. 33.0.0.0 -> 11.0.0.0
8. 11.0.0.0 -> 22.0.0.0
9. 11.0.0.0 -> 22.0.0.0
```

Pakety 1, 4, 8 a 9 tvoria jeden tok.
Paket 2 tvorÃ­ samostatnÃ½ tok (teda komunikÃ¡cia v rÃ¡mci jednÃ©ho toku je vÅ¾dy iba
jednosmernÃ¡).
Pakety 3 a 6 patria k ÄalÅ¡iemu toku.
Pakety 5 a 7 patria k tokom, ktorÃ© sÃº tvorenÃ© iba jednÃ½m paketom.

VaÅ¡ou Ãºlohou bude naimplementovaÅ¥ dve funkcie.

```c
int print_flow_stats(const struct capture_t *const capture);
int print_longest_flow(const struct capture_t *const capture);
```

Funkcia `print_flow_stats` vypÃ­Å¡e informÃ¡cie o vÅ¡etkÃ½ch tokoch.
Pre kaÅ¾dÃ½ tok vypÃ­Å¡e presne jeden riadok v tvare

```
<ip_from> -> <ip_to> : <packet_count>
```

kde `<ip_from>` je zdrojovÃ¡ IP adresa, `<ip_to>` je cieÄ¾ovÃ¡ adresa
a `<packet_count>` je poÄet paketov, ktorÃ© sa v tomto toku nachÃ¡dzajÃº.
Riadky budÃº vypÃ­sanÃ© v poradÃ­, v akom sa v zÃ¡zname vyskytujÃº prvÃ© pakety
patriace jednotlivÃ½m tokom.
UvedenÃ©mu prÃ­kladu by teda zodpovedal vÃ½sledok:

```
11.0.0.0 -> 22.0.0.0 : 4
22.0.0.0 -> 11.0.0.0 : 1
33.0.0.0 -> 44.0.0.0 : 2
11.0.0.0 -> 44.0.0.0 : 1
33.0.0.0 -> 11.0.0.0 : 1
```

Funkcia `print_longest_flow` vypÃ­Å¡e presne jeden riadok v tvare

```
<ip_from> -> <ip_to> : <start_seconds>:<start_microseconds/nanoseconds> - <end_seconds>:<end_microseconds/nanoseconds>
```

a to pre najdlhÅ¡Ã­ tok, ktorÃ½ sa v zÃ¡zname nachÃ¡dza.
Za zaÄiatok toku sa povaÅ¾uje ÄasovÃ¡ znÃ¡mka jeho prvÃ©ho paketu a za koniec ÄasovÃ¡
znÃ¡mka jeho poslednÃ©ho paketu.
PokiaÄ¾ sa v zÃ¡zname nachÃ¡dza viac tokov s rovnakou dÄºÅ¾kou v sekundÃ¡ch, je
rozhodujÃºca dÄºÅ¾ka toku v rozlÃ­Å¡enÃ­ mikrosekÃºnd alebo nanosekÃºnd.
Ak bude aj takÃ½chto tokov viac, funkcia vypÃ­Å¡e ten, ktorÃ½ sa v zÃ¡zname objavil
ako prvÃ½.

MÃ´Å¾ete predpokladaÅ¥, Å¾e pakety sÃº v zÃ¡zname v sprÃ¡vnom poradÃ­, teda pre
Ä¾ubovoÄ¾nÃº dvojicu paketov _P1_ a _P2_, kde _P2_ bol funkciou `load_packet`
naÄÃ­tanÃ½ neskÃ´r neÅ¾ _P1_, platÃ­, Å¾e ÄasovÃ¡ znÃ¡mka _T_ paketu _P2.T_ >= _P1.T_.

Obe funkcie v prÃ­pade zlyhania uvoÄ¾nia vÅ¡etku vlastnÃº doposiaÄ¾ naalokovanÃº pamÃ¤Å¥
(postarajÃº sa iba o alokÃ¡cie, ku ktorÃ½m doÅ¡lo v rÃ¡mci aktuÃ¡lneho volania
funkcie).
Pri zlyhanÃ­ skonÄia s nenulovou nÃ¡vratovou hodnotou a na Å¡tandardnÃ½ chybovÃ½
vÃ½stup vypÃ­Å¡u prÃ¡ve jeden riadok s Ä¾ubovoÄ¾nou *zmysluplnou* chybovou hlÃ¡Å¡kou.
V tomto prÃ­pade nebudeme testovaÅ¥, Äi doÅ¡lo k nejakÃ©mu vÃ½pisu na `stdout`.

PrÃ¡zdny zÃ¡znam s poÄtom paketov rovnÃ½ nule povaÅ¾ujte pri funkcii
`print_longest_flow` za nekorektnÃ½ vstup a zareagujte naÅˆ ako na zlyhanie
funkcie.

=== 4. CLI program

Na zÃ¡ver naimplementujete jednoduchÃ½ program, ktorÃ½ pomocou kniÅ¾nice `capture.h`
vykonÃ¡ analÃ½zu sÃºboru pcap a vypÃ­Å¡e zvolenÃº Å¡tatistiku.
Volanie programu vyzerÃ¡ nasledovne:

```
./nft <input_file> <from+mask> <to+mask> <statistic>
```

argumenty:

* `<input_file>` cesta k pcap sÃºboru
* `<from+mask>` adresa a maska zdrojovej podsiete zapÃ­sanÃ¡ v tvare a.b.c.d/bits
* `<to+mask>` adresa a maska cieÄ¾ovej podsiete zapÃ­sanÃ¡ v tvare a.b.c.d/bits
* `<statistic>` bude `flowstats` alebo `longestflow`

Program naÄÃ­ta zÃ¡znam zo sÃºboru `<input_file>`, vyfiltruje jeho obsah na zÃ¡klade
`<from+mask>` a `<to+mask>` a nÃ¡sledne nad vÃ½slednÃ½m zÃ¡znamom zavolÃ¡ funkciu
`print_flow_stats` alebo `print_longest_flow` podÄ¾a toho, Äo obsahuje argument
`<statistic>`.

NaprÃ­klad volanie s dodanÃ½m sÃºborom

```
./nft test.pcap 0.0.0.0/0 0.0.0.0/0 flowstats
```

pri sprÃ¡vnej implementacii vypÃ­Å¡e:

```
172.16.11.12 -> 74.125.19.17 : 3
74.125.19.17 -> 172.16.11.12 : 2
216.34.181.45 -> 172.16.11.12 : 3
172.16.11.12 -> 216.34.181.45 : 2
```

MÃ´Å¾ete oÄakÃ¡vaÅ¥, Å¾e argumenty pre IP adresu budÃº v sprÃ¡vnom tvare.
Inak povedanÃ©, na naÄÃ­tanie celej jednej masky z argumentu bude staÄiÅ¥ jedno
volanie `sscanf` s formÃ¡tovacÃ­m reÅ¥azcom, ktorÃ½ obsahuje znaÄku `%` prÃ¡ve 5-krÃ¡t
ğŸ˜‰.
Nie je ale na Å¡kodu aj tak oÅ¡etriÅ¥ nesprÃ¡vne vstupy â€“ pozrite sa do
dokumentÃ¡cie, Äo funkcia `sscanf` vracia.

V prÃ­pade nesprÃ¡vneho poÄtu argumentov program vrÃ¡ti nenulovÃ½ nÃ¡vratovÃ½ kÃ³d
a vypÃ­Å¡e na Å¡tandardnÃ½ chybovÃ½ vÃ½stup jeden riadok s Ä¾ubovoÄ¾nou *zmysluplnou*
chybovou hlÃ¡Å¡kou.
Podobne v prÃ­pade nesprÃ¡vnych argumentov (naprÃ­klad bits > 32, nesprÃ¡vny nÃ¡zov
Å¡tatistiky).
ÄŒÃ­sla v zadanej IP adrese mimo rozsahu 0-255 pre zjednoduÅ¡enie testovaÅ¥ nebudeme.
Funkcie pre Å¡tatistiky v prÃ­pade zlyhania uÅ¾ na Å¡tandardnÃ½ chybovÃ½ vÃ½stup nieÄo
vypisujÃº â€“ v tomto prÃ­pade samotnÃ½ program na `stderr` nepridÃ¡ niÄ ÄalÅ¡ie, ale
stÃ¡le skonÄÃ­ s nenulovÃ½m nÃ¡vratovÃ½m kÃ³dom.

IMPORTANT: V programe sa nespoliehajte na vami definovanÃ½ obsah Å¡truktÃºry
`capture_t`!
So zÃ¡znamami narÃ¡bajte iba pomocou funkciÃ­ deklarovanÃ½ch v `capture.h`.
VÃ¡Å¡ program bude pri testovanÃ­ kompilovanÃ½ aj s nami dodanÃ½mi
`capture.h`/`capture.c`, ktorÃ© si Å¡truktÃºru nadefinujÃº inak ako vy!

== PoÅ¾iadavky

Nesmiete sa spoliehaÅ¥ na vlastnÃ© Ãºpravy sÃºborov `pcap.h` a `pcap.c`.
Pri testovanÃ­ budÃº pouÅ¾itÃ© pÃ´vodnÃ© sÃºbory a vaÅ¡e zmeny v nich teda budÃº ignorovanÃ©.

V sÃºbore `capture.h` nesmiete upraviÅ¥ existujÃºce deklarÃ¡cie funkciÃ­.
NepridÃ¡vajte do sÃºboru Å¾iadne pomocnÃ© funkcie, tie patria len do sÃºboru `capture.c`.
MÃ´Å¾ete do sÃºboru pridaÅ¥ `include`, pokiaÄ¾ to vyÅ¾aduje nejakÃ½ typ, ktorÃ½ chcete
v Å¡truktÃºre pouÅ¾iÅ¥.
VzorovÃ¡ implementÃ¡cia sa zaobÃ­de aj bez toho.

VÃ¡Å¡ program z Äasti 4 sa musÃ­ pri prÃ¡ci so zÃ¡znamami spoliehaÅ¥ len a len na
funkcie definovanÃ© v sÃºbore `capture.h`.
PokiaÄ¾ si v `capture.c` definujete pomocnÃ© funkcie, v programe ich nebude moÅ¾nÃ©
pouÅ¾iÅ¥.
V tejto Äasti sa taktieÅ¾ nespoliehajte na vami definovanÃ½ obsah Å¡truktÃºry `capture_t`.
K obsahu tejto Å¡truktÃºry by mali pristupovaÅ¥ iba funkcie definovanÃ© v sÃºbore `capture.h`.
Pri testovanÃ­ vÃ¡Å¡ho programu v sÃºbore `nft.c` mÃ´Å¾u a budÃº sÃºbory `capture.h`
a `capture.c` nahradenÃ© vzorovÃ½m rieÅ¡enÃ­m.

Program musÃ­ pred ukonÄenÃ­m sprÃ¡vne uvoÄ¾niÅ¥ vÅ¡etku naalokovanÃº pamÃ¤Å¥.

== PoznÃ¡mky

=== Tipy a triky

* Na vyreÅ¡enie Ãºlohy sÃºbor `nft.c` vÃ´bec nemusÃ­ obsahovaÅ¥ `#include "pcap.h"`
  (a ani by nemal).

* VyuÅ¾Ã­vajte dodanÃ½ sÃºbor `demo.c` a testy Äo najviac.
  NepÃºÅ¡Å¥ajte sa do programovania ÄalÅ¡ej Äasti Ãºlohy, pokiaÄ¾ si poriadne
  neotestujete pouÅ¾itie predchÃ¡dzajÃºcej Äasti.
  Chyby v naÄÃ­tavanÃ­ a funkciÃ¡ch `get_header` a `get_packet` negatÃ­vne ovplyvnia
  sprÃ¡vanie aj testy filtrovacÃ­ch funkciÃ­ a Å¡tatistÃ­k.

* DokumentÃ¡ciu k funkciÃ¡m, ktorÃ© sa nachÃ¡dzajÃº v hlaviÄkovÃ½ch sÃºboroch,
  povaÅ¾ujte za sÃºÄasÅ¥ zadania.

* SprÃ¡vne oÅ¡etrujte chybovÃ© stavy nielen v dodanÃ½ch funkciÃ¡ch, ale aj pri
  volaniach Å¡tandardnÃ½ch funkciÃ­ jazyka C.
  Program musÃ­ uvoÄ¾niÅ¥ pamÃ¤Å¥ aj pri zlyhanÃ­ tÃ½chto funkciÃ­.

* Pozor na umiestnenie sÃºboru `test.pcap` vzhÄ¾adom ku skompilovanÃ½m binÃ¡rkam.
  Testy aj demo ho oÄakÃ¡vajÃº v rovnakom adresÃ¡ri, takÅ¾e ak kompilujete programy
  do build adresÃ¡rov, nezabudnite do nich sÃºbor test.pcap skopÃ­rovaÅ¥.

== VzorovÃ¡ implementÃ¡cia

VzorovÃº implementÃ¡ciu nÃ¡jdete v `/home/kontr/pb071/hw03/nft`.
Na nej si mÃ´Å¾ete vyskÃºÅ¡aÅ¥ oÄakÃ¡vanÃ© sprÃ¡vanie CLI programu.

V rovnakom adresÃ¡ri nÃ¡jdete aj program filterer, pomocou kterÃ©ho mÃ´Å¾ete
otestovaÅ¥ sprÃ¡vne chovanie filtrovacÃ­ch funkciÃ­.
Pre viac informÃ¡ciÃ­ si na Aise spustite `/home/kontr/pb071/hw03/filterer --help`.

== Testy

V kostre nÃ¡jdete priloÅ¾enÃ© ukÃ¡Å¾kovÃ© testy.
Tie sÃº zÃ¡merne veÄ¾mi povrchnÃ©, z obsahu naÄÃ­tanÃ©ho paketu naprÃ­klad kontrolujÃº
len jeho dÄºÅ¾ku.
Ich obsah vÃ¡m vÅ¡ak veÄ¾mi dobre poslÃºÅ¾i ako nÃ¡vod, ako si podÄ¾a nich napÃ­saÅ¥
vlastnÃ© a komplexnejÅ¡ie testy.

V sÃºbore `tests/tests-unit.c` nÃ¡jdete ukÃ¡Å¾ky unit testov na testovanie
jednotlivÃ½ch funkciÃ­.
SÃºbor `tests/tests-e2e.c` potom obsahuje ukÃ¡Å¾ky testov, ktorÃ© otestujÃº vÃ¡Å¡
kompletnÃ½ program.

=== Testy naneÄisto

Z dodanÃ½ch testov vÃ¡m naneÄisto musia prejsÅ¥ iba `load_capture_basic`
a `filter_from_to_basic`.
OstatnÃ© testy berte ako pozornosÅ¥ podniku.
PokiaÄ¾ vÃ¡m vÅ¡ak neprechÃ¡dzajÃº, veÄ¾mi nepoÄÃ­tajte s veÄ¾kÃ½m poÄtom bodov z ostrÃ½ch
testov.

Okrem toho sa bude v testoch naneÄisto kontrolovaÅ¥, Äi ste neupravili v sÃºbore
`capture.h` niÄ okrem zadanej Å¡truktÃºry a takieÅ¾, Äi sa vÃ¡Å¡ `nft.c` skompiluje
s naÅ¡imi `capture.h`/`capture.c` a naopak, Äi sa nÃ¡Å¡ `nft.c` skompiluje s vaÅ¡imi
`capture.h`/`capture.c`.
